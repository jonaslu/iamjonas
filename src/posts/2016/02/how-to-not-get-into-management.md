---
title: "How to not get into management"
date: 2016-02-21
summary: "Do you still love programming and want to continue to program forever-ever?"
---

Is gerascophobia rampant in programming? If you start [googling this](https://www.google.se/search?q=ageism+programmer) (and really what phobia doesn't get better with endless googling) - the advice is usually to have a plan B before you hit your 40-ies (or 35-ies, or...). The plan being to land a management position now while the tide it still good and then weather it out.

In that pile of googling you're also bound to find some depressing stories of older programmers now unwanted and thrown to the dumps with the assumption that it's old age. But what if you still love to code? Short of opting for management - where does the notion that older programmers are obsolete come from and what do you do about it?

## Everyone's invited!
First of all, let's put this in perspective. I think that it hurts more when you have some mileage in the industry - but not being hired is a universal problem.

It's very common that junior programmers doesn't get hired too - but so commonplace it's not making great headlines. As a programmer fresh out of university you may be cheap but getting the first stamp of approval it's equally hard - if not harder. Someone has to have the guts to bet on you.

How is that first job landed? Very often via contacts. Why? Because the contacts can testify that you are a-ok. You are not a total jerk and can cooperate with others.

According to all recruiters I've spoken to - being a jerk and not being able to cooperate is usually the biggest problem hiring developers. The people skills seldom match the technical skills and the two happening in the same person is rare. Which makes the advice to go into management even more hilarious.

## Stagnantism
This [article](http://techcrunch.com/2010/08/28/silicon-valley%E2%80%99s-dark-secret-it%E2%80%99s-all-about-age/) (old and severly quoted by others I know but it serves as a base for most biases) - kind of hits the nail on the head:

> The young understand new technologies better than the old do, and are like a clean slate: they will rapidly learn the latest coding methods and techniques, and they don’t carry any “technology baggage”.

This bias is based on the[irrelevant notion](https://www.researchgate.net/profile/Becca_Levy/publication/15151830_Aging_free_from_negative_stereotypes_successful_memory_in_China_and_among_the_American_deaf/links/541b180d0cf25ebee988fd00.pdf)that old dogs can't be taught new tricks.[Research](http://www.sciencedaily.com/releases/2016/02/160202121818.htm)show they're perfectly capable of learning new tricks - albeit at a somewhat slower pace.

Now - given [Ecclastes 1:9](https://www.biblegateway.com/passage/?search=Ecclesiastes%201:9)- and if you've studied a bit how the mind works this is actually a fallacy. Learning and retaining information is much easier if you already know the area. The new will be learnt by relating information to what you already know.

A seasoned programmer worth their salt should be able to pick up a new language within weeks - because there arenoseldom new ideas - onlymostlyvariations.

## Grumpy pants
What can't be "[rapidly learned](https://en.wikipedia.org/wiki/No_Silver_Bullet)" is making trade-offs and managing complexity.

Having been around for a while will can make you more grumpy (a.k.a carrying "technological baggage") because you can more easily see the trade-offs and pitfalls of the next new thing (that is really just the same old thing in a new package).

Of course this is unpleasant and causes a rift with other stakeholders. It's not popular to have to say no and talk about the trade-offs you are making. A new developer will probably say yes yes to anything because there are (yet) no limits.

## Pricetagism
More relevant experience should command a higher pay. If you think about it - programming is by large and far a knowledge industry. You've got to know things to be valuable to someone. In the end it's about churning out code that solves someones real world problem **now** (or even **yesterday**). In this respect age has little to do with it.

Age in this respect is more of a guise for trying to land a bargain - the preference towards junior programmers must be largely for their pricetag. If pricetags were equal amongst developer - why not go for the guy with 10 or 20 years of relevant experience?

That and proneness to do death marches since there are usually few family obligations for young devs - and that makes that price tag sometimes very very cheap.

## Todo: what to do?
Countering this with price dumping won't be a viable or even advisable. Your pricetag is expected to be up if you've been in the game for a while. It's some kind of quality stamp proving that you are good at what you do.

## Embrace evolvism
Disprove the notion of stagnantism. A stagnant resume will reflect on an inability or aversion to continual learning. A really honest question to ask yourself is whether new things gets you interested or not. If not - it's going to be a long downwards journey from here on. Your hireability will highly relate to the ability to learn things.

Even if this is the umpteenth time you've seen the same old technique touted as the new Jesus of programming - get that thing on your resume. Call it r'n'd if it makes you feel better. You are r'n'd ing your most valuable product - your resume.

Find a good balance between things that are interesting and things that are in vogue or on the rise. Get at least some things that are currently "hot" on your resume to prove that you are still learning new tricks.

## Improve not being a jerk
This extends to things beyond mere work. Go visible. Help out somewhere. [Get a blog and write some](http://catchmecode.com/). Register on stack overflow. Join an open source project. Push things that might be useful to others on github. Organize meetups. Go to conferences. Talk to all kinds of people. Offer to help.

While the above statement is and must be based on sincere altruism it will result in building and proving that you are (or trying to improve yourself) as a people person.

## ...tempered with some patience
Blaming not getting hired on only age reminds me of the saying that when you point the finger at someone there is three pointing back at you.

Just like your first job - be ok with that not every place would be a good fit. If you've done all the homework above - the job ad is a match and you'd think you are a good fit and still get sidelined - maybe there are other blind spots at that place? Maybe the image doesn't match the contents. Move on.

## ...and some blatant self-confidence
The continued proof via failed software projects that[simplicity is hard](http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD896.html)- and that it's flipside[complexity causing systems to break](https://en.wikipedia.org/wiki/The_Mythical_Man-Month)- will hopefully one day cause a shift to re-think the short term valuation of price, perceived stagnantism and grumpyness over experience.

Learning to deal with complexity is done via experience. You have to see things go sour for yourself to know what to do with it. If the hiring process at some place thinks of developers as commodities - I'm a bit weary as to how the rest of the reasoning goes in such places.

Pride yourself in having built stuff that actually worked ([except when it didn't](http://www.catchmecode.com/2013/06/bug-repellants.html)). Its not easy.

## Let's revel in the stats
[Programmers are in demand](http://www.bls.gov/ooh/computer-and-information-technology/software-developers.htm#tab-6) - the amount of software now in even your toaster is staggering. Someone needs to maintain, upgrade and write that software. And the supply is not increasing at the same rate. There just aren't that [developers to go around](http://mashable.com/2014/08/21/programming-as-a-second-career/#skhuZd2L6qqF).

So, given that you do your homework - and that you are ok with some places turning you down not knowing that complexity kills - I'd say its a really bad time to get out of programming if you're just a tad mindful of where you are heading.

Because programming is still fun. And horrible.
